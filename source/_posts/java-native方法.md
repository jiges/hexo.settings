---
title: java native方法
date: 2017-11-21 10:17:38
tags: 
		- java
		- native
categories: java
---
# 概述
JNI（Java Native Interface,Java本地接口）是一种编程框架,使得Java虚拟机中的Java程序可以调用本地应用/或库,也可以被其他程序调用。本地程序一般是用其它语言（C、C++或汇编语言等）编写的, 并且被编译为基于本机硬件和操作系统的程序。
<!-- more -->

我们知道，java标准库不支持的平台相关功能或者程序库，JNI允许程序员用其他编程语言来解决用纯粹的Java代码不好处理的情况，说白了java是高级的语言，纯粹的代码语言，不能直接和系统硬件对接，必须借助JNI来实现和平台系统的对接。许多基于JNI的标准库提供了很多功能给程序员使用, 例如文件I/O、音频相关的功能等。
> 关于JNI的解释，百度google一大堆，笔者可自行去理解。本文只是说明`JVM`是如何调用`native方法`的。

# [陷阱与诱惑](https://zh.wikipedia.org/wiki/Java%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3)
- 在使用JNI的过程中,可能因为某些微小的BUG,对整个JVM造成很难重现和调试的错误。
- 依赖于JNI的应用失去了Java的平台移植性（一种解决办法是为每个平台编写专门的JNI代码，然后在Java代码中,根据操作系统载入正确的JNI代码）。
- JNI框架并没有对 non-JVM 内存提供自动垃圾回收机制, Native代码(如汇编语言)分配的内存和资源，需要其自身负责进行显式的释放。
- JNI在某些情况下可能带来很大的开销和性能损失。
    - 调用 JNI 方法是很笨重的操作, 特别是在多次重复调用的情况下。
    - Native 方法不会被 JVM 内联, 也不会被 JIT compiled 优化 , 因为方法已经被编译过了。
    - Java 数组可能会被拷贝一份,以传递给 native 方法, 执行完之后再拷贝回去. 其开销与数组的长度是线性相关的.
    - 如果传递一个对象给方法,或者需要一个回调,那么 Native 方法可能会自己调用JVM。 访问Java对象的属性、方法和类型时, Native代码需要类似reflection的东西。签名由字符串指定,通从JVM中查询。这非常缓慢并且容易出错。
    - Java 中的字符串(String) 也是对象, 有 length 属性,并且是编码过的. 读取或者创建字符串都需要一次时间复杂度为 O(n) 的复制操作.

# JNI开发流程
> 参考[极客学院JNI开发流程](http://wiki.jikexueyuan.com/project/jni-ndk-developer-guide/workflow.html)

开发 JNI 程序会受到系统环境的限制，因为用 C/C+- 语言写出来的代码或模块，编译过程当中要依赖当前操作系统环境所提供的一些库函数，并和本地库链接在一起。而且编译后生成的二进制代码只能在本地操作系统环境下运行，因为不同的操作系统环境，有自己的本地库和 CPU 指令集，而且各个平台对标准 C/C+- 的规范和标准库函数实现方式也有所区别。这就造成使用了 JNI 接口的 JAVA 程序，不再像以前那样自由的跨平台。如果要实现跨平台，就必须将本地代码在不同的操作系统平台下编译出相应的动态库。  
JNI 开发流程主要分为以下 6 步： 

- 编写声明了 native 方法的 Java 类。
- 将 Java 源代码编译成 class 字节码文件
- 用 javah -jni 命令生成.h头文件（javah 是 jdk 自带的一个命令，-jni 参数表示将 class 中用native 声明的函数生成 JNI 规则的函数）
- 用本地代码实现.h头文件中的函数
- 将本地代码编译成动态库（Windows：\*.dll，linux/unix：\*.so，mac os x：\*.jnilib）
- 拷贝动态库至 java.library.path 本地库搜索目录下，并运行 Java 程序  

![开发流程](开发流程.png)

## 开发HelloWorld程序
> 以在linux环境下开发编译为例  


### 编写声明了 native 方法的 Java 类
```java
public class HelloJNI {
	
	public static native String sayHello(String name); // 1.声明这是一个native函数，由本地代码实现
	
	public static void main(String[] args) {
        String text = sayHello("hello jni");  // 3.调用本地函数
        System.out.println("Hello,I'm java,the return String is : " + text);
    }

    static {
        System.loadLibrary("HelloJNI");   // 2.加载实现了native函数的动态库，只需要写动态库的名字
    }
}

```  


### 编译class文件
```java
$  /home/ccr/jdk1.7.0_80/bin/javac -cp /home/ccr/jdk1.7.0_80/jre/lib/rt.jar HelloJNI.java 
```  

### 生成.h头文件
`.h头文件`可以类比java接口类去理解。.h中一般放的是同名.c文件中定义的变量、数组、函数的声明，需要让.c外部使用的声明。头文件中只是申明变量函数，具体的初始化和实现放在同名`.c`文件或`.cpp`文件中。
```java
$  /home/ccr/jdk1.7.0_80/bin/javah -jni -d ./jni HelloJNI
```  
参数说明:

- classpath：类搜索路径，这里表示从当前的 bin 目录下查找
- d：将生成的头文件放到当前的 jni 目录下
- o： 指定生成的头文件名称，默认以类全路径名生成（包名+类名.h）

> 注意：-d和-o只能使用其中一个参数。

生成的头文件jni/HelloJNI.h
```c++
/- DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/- Header for class HelloJNI */

#ifndef _Included_HelloJNI
#define _Included_HelloJNI
#ifdef __cplusplus
extern "C" {
#endif
/*
 - Class:     HelloJNI
 - Method:    sayHello
 - Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_HelloJNI_sayHello
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif

```  

### 实现头文件中申明的函数
编辑HelloJNI.c
```c
// HelloJNI.c
#include <jni.h>
/- Header for class HelloJNI */

#ifdef __cplusplus  
extern "C"  
{  
#endif  
/*
 - Class:     HelloJNI
 - Method:    sayHello
 - Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_HelloJNI_sayHello
  (JNIEnv *env, jclass cls, jstring j_str)
  {  
    const char *c_str = NULL;  
    char buff[128] = { 0 };  
    c_str = (*env)->GetStringUTFChars(env, j_str, NULL);  
    if (c_str == NULL)  
    {  
        printf("out of memory.\n");  
        return NULL;  
    }  
    (*env)->ReleaseStringUTFChars(env, j_str, c_str);  
    printf("Hello,I'm C++,the Java Str is:%s\n", c_str); 
    sprintf(buff, "hello %s", c_str);  
    return (*env)->NewStringUTF(env, buff);  
}  

#ifdef __cplusplus  
}  
#endif 
```  

### 编译C文件

将 C/C+- 代码编译成本地动态库文件动态库文件名命名规则：lib+动态库文件名+后缀（操作系统不一样，后缀名也不一样）如：

- Mac OS X : libHelloJNI.jnilib
- Windows ：HelloJNI.dll（不需要 lib 前缀）
- Linux/Unix：libHelloJNI.so

以在linux环境下编译为例
```c
$  gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared HelloJNI.c -o libHelloJNI.so
```  

参数说明：
- -I： 包含编译JNI必要的头文件
- -fPIC： 编译成与位置无关的独立代码
- -shared：编译成动态库
- -o： 指定编译后动态库生成的路径和文件名

### 运行 Java 程序
```c
$  /home/ccr/jdk1.7.0_80/bin/java HelloJNI 
```  
Java 在调用 native (本地)方法之前，需要先加载动态库。如果在未加载动态之前就调用 native 方法，会抛出找不到动态链接库文件的异常。如下所示:
```java
Exception in thread "main" java.lang.UnsatisfiedLinkError: no HelloJNI in java.library.path
        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1886)
        at java.lang.Runtime.loadLibrary0(Runtime.java:849)
        at java.lang.System.loadLibrary(System.java:1088)
        at HelloJNI.<clinit>(HelloJNI.java:11)
```  
一般在类的静态（static）代码块中加载动态库最合适，因为在创建类的实例时，类会被 `ClassLoader` 先加载到虚拟机，随后立马调用类的 `static` 静态代码块。这时再去调用 `native` 方法就万无一失了。加载动态库的两种方式：

```java
System.loadLibrary("HelloJNI");  
System.load("/home/ccr/jvm/javatest/libHelloJNI.so"); 
```  

- 方式1：只需要指定动态库的名字即可，不需要加lib前缀，也不要加.so、.dll和.jnilib后缀
- 方式2：指定动态库的绝对路径名，需要加上前缀和后缀

如果使用方式1，`java` 会去 `java.library.path` 系统属性指定的目录下查找动态库文件，如果没有找到会抛出`java.lang.UnsatisfiedLinkError` 异常。  
只需要指定 `java.library.path` 即可
```c
$  /home/ccr/jdk1.7.0_80/bin/java -Djava.library.path=/home/ccr/jvm/javatest HelloJNI 
```  
# JVM 查找 native 方法
调用 `native` 方法之前，首先要调用 `System.loadLibrary` 接口加载一个实现了`native` 方法的动态库才能正常访问，否则就会抛出 `java.lang.UnsatisfiedLinkError` 异常，找不到 XX 方法的提示。现在我们想想，在 `Java` 中调用某个 `native` 方法时，`JVM` 是通过什么方式，能正确的找到动态库中 `C/C++` 实现的那个 `native` 函数呢？  

`JVM` 查找`native` 方法有两种方式：

- 按照 `JNI` 规范的命名规则
- 调用 `JNI` 提供的 `RegisterNatives` 函数，将本地函数注册到 `JVM`中。

上一节中的示例使用的就是第一种方式